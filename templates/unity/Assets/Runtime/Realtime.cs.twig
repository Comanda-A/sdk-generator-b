using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Text;
using System.Text.Json;
using Cysharp.Threading.Tasks;
using UnityEngine;
using NativeWebSocket;

namespace {{ spec.title | caseUcfirst }}
{
    /// <summary>
    /// Realtime response event structure
    /// </summary>
    [Serializable]
    public class RealtimeResponseEvent<T>
    {
        public string[] Events { get; set; }
        public string[] Channels { get; set; }
        public long Timestamp { get; set; }
        public T Payload { get; set; }
    }

    /// <summary>
    /// Realtime subscription for Unity
    /// </summary>
    public class RealtimeSubscription
    {
        public string[] Channels { get; internal set; }
        public Action<RealtimeResponseEvent<Dictionary<string, object>>> OnMessage { get; internal set; }
        internal Action OnClose { get; set; }

        /// <summary>
        /// Close this subscription
        /// </summary>
        public void Close()
        {
            OnClose?.Invoke();
        }
    }

    /// <summary>
    /// Realtime connection interface for Unity WebSocket communication
    /// </summary>
    public class Realtime
    {
        private readonly Client _client;
        private WebSocket _webSocket;
        private readonly HashSet<string> _channels;
        private readonly Dictionary<int, RealtimeSubscription> _subscriptions;
        private int _subscriptionCounter;
        private bool _reconnect = true;
        private int _reconnectAttempts = 0;
        private const int MaxReconnectAttempts = 100;
        private CancellationTokenSource _cancellationTokenSource;
        private bool _creatingSocket = false;
        private string _lastUrl;
        private CancellationTokenSource _heartbeatTokenSource;

        public bool IsConnected => _webSocket?.State == WebSocketState.Open;
        public event Action OnConnected;
        public event Action OnDisconnected;
        public event Action<Exception> OnError;

        public Realtime(Client client)
        {
            _client = client;
            _channels = new HashSet<string>();
            _subscriptions = new Dictionary<int, RealtimeSubscription>();
            _subscriptionCounter = 0;
        }

        /// <summary>
        /// Subscribe to realtime events
        /// </summary>
        public RealtimeSubscription Subscribe(string[] channels, Action<RealtimeResponseEvent<Dictionary<string, object>>> callback)
        {
            Debug.Log($"[Realtime] Subscribe called for channels: [{string.Join(", ", channels)}]");
            
            var subscriptionId = ++_subscriptionCounter;
            var subscription = new RealtimeSubscription
            {
                Channels = channels,
                OnMessage = callback,
                OnClose = () => CloseSubscription(subscriptionId, channels)
            };

            _subscriptions[subscriptionId] = subscription;
            
            // Add channels to the set
            foreach (var channel in channels)
            {
                _channels.Add(channel);
            }

            Debug.Log($"[Realtime] Total channels now: {_channels.Count}");
            
            // Create socket if needed
            CreateSocket().Forget();

            return subscription;
        }

        private void CloseSubscription(int subscriptionId, string[] channels)
        {
            _subscriptions.Remove(subscriptionId);

            // Remove channels that are no longer in use
            foreach (var channel in channels)
            {
                bool stillInUse = _subscriptions.Values.Any(s => s.Channels.Contains(channel));
                if (!stillInUse)
                {
                    _channels.Remove(channel);
                }
            }

            // Recreate socket with new channels or close if none
            if (_channels.Count > 0)
            {
                CreateSocket().Forget();
            }
            else
            {
                CloseConnection().Forget();
            }
        }

        private async UniTask CreateSocket()
        {
            if (_creatingSocket || _channels.Count == 0) return;
            _creatingSocket = true;
            
            Debug.Log($"[Realtime] Creating socket for {_channels.Count} channels");

            try
            {
                var uri = PrepareUri();
                Debug.Log($"[Realtime] Connecting to URI: {uri}");
                
                if (_webSocket == null || _webSocket.State == WebSocketState.Closed)
                {
                    _webSocket = new WebSocket(uri);
                    _lastUrl = uri;
                    SetupWebSocketEvents();
                }
                else if (_lastUrl != uri && _webSocket.State != WebSocketState.Closed)
                {
                    await CloseConnection();
                    _webSocket = new WebSocket(uri);
                    _lastUrl = uri;
                    SetupWebSocketEvents();
                }

                if (_webSocket.State == WebSocketState.Connecting || _webSocket.State == WebSocketState.Open)
                {
                    Debug.Log($"[Realtime] Socket already connecting/connected: {_webSocket.State}");
                    _creatingSocket = false;
                    return;
                }

                Debug.Log("[Realtime] Attempting to connect...");
                await _webSocket.Connect();
                Debug.Log("[Realtime] Connect call completed");
                _reconnectAttempts = 0;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[Realtime] Connection failed: {ex.Message}");
                OnError?.Invoke(ex);
                Retry();
            }
            finally
            {
                _creatingSocket = false;
            }
        }

        private void SetupWebSocketEvents()
        {
            _webSocket.OnOpen += OnWebSocketOpen;
            _webSocket.OnMessage += OnWebSocketMessage;
            _webSocket.OnError += OnWebSocketError;
            _webSocket.OnClose += OnWebSocketClose;
        }

        private void OnWebSocketOpen()
        {
            _reconnectAttempts = 0;
            OnConnected?.Invoke();
            StartHeartbeat();
            Debug.Log($"[Realtime] WebSocket opened successfully: {_lastUrl}");
        }

        private void OnWebSocketMessage(byte[] data)
        {
            try
            {
                var message = Encoding.UTF8.GetString(data);
                Debug.Log($"[Realtime] Raw message: {message}"); // Debug incoming messages
                var response = JsonSerializer.Deserialize<Dictionary<string, object>>(message, Client.DeserializerOptions);
                
                if (response.TryGetValue("type", out var typeObj))
                {
                    var messageType = typeObj?.ToString();
                    Debug.Log($"[Realtime] Message type: {messageType}"); // Debug message type
                    
                    switch (messageType)
                    {
                        case "connected":
                            HandleConnectedMessage(response);
                            break;
                        case "event":
                            HandleRealtimeEvent(response);
                            break;
                        case "error":
                            HandleErrorMessage(response);
                            break;
                        case "pong":
                            // Debug.Log("Received heartbeat response from realtime server"); // Remove debug log
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                OnError?.Invoke(ex);
            }
        }

        private void HandleConnectedMessage(Dictionary<string, object> response)
        {
            // Handle authentication if no user is present
            if (response.TryGetValue("data", out var dataObj) && dataObj is Dictionary<string, object> data)
            {
                var hasUser = data.TryGetValue("user", out var userObj) && 
                             userObj is Dictionary<string, object> user && user.Count > 0;
                             
                if (!hasUser)
                {
                    SendFallbackAuthentication();
                }
            }
            
            // Start heartbeat after successful connection (moved from OnWebSocketOpen)
            // StartHeartbeat(); // Already called in OnWebSocketOpen
        }

        private void SendFallbackAuthentication()
        {
            var session = _client.Config.TryGetValue("session", out var sessionValue) ? sessionValue : null;
            
            if (!string.IsNullOrEmpty(session))
            {
                var authMessage = new
                {
                    type = "authentication",
                    data = new { session }
                };

                var json = JsonSerializer.Serialize(authMessage, Client.SerializerOptions);
                _webSocket.SendText(json);
            }
        }

        private void HandleErrorMessage(Dictionary<string, object> response)
        {
            if (response.TryGetValue("data", out var dataObj) && dataObj is Dictionary<string, object> data)
            {
                var message = data.TryGetValue("message", out var msgObj) ? msgObj?.ToString() : "Unknown realtime error";
                var code = data.TryGetValue("code", out var codeObj) ? Convert.ToInt32(codeObj) : 0;
                
                OnError?.Invoke(new {{ spec.title | caseUcfirst }}Exception(message, code));
            }
        }

        private void HandleRealtimeEvent(Dictionary<string, object> response)
        {
            try
            {
                if (response.TryGetValue("data", out var dataObj) && dataObj is Dictionary<string, object> data)
                {
                    var channels = data.TryGetValue("channels", out var channelsObj) ? 
                        JsonSerializer.Deserialize<string[]>(channelsObj.ToString()) : new string[0];
                    var events = data.TryGetValue("events", out var eventsObj) ? 
                        JsonSerializer.Deserialize<string[]>(eventsObj.ToString()) : new string[0];
                    var timestamp = data.TryGetValue("timestamp", out var timestampObj) ? 
                        Convert.ToInt64(timestampObj) : 0;
                    var payload = data.TryGetValue("payload", out var payloadObj) ? 
                        JsonSerializer.Deserialize<Dictionary<string, object>>(payloadObj.ToString()) : new Dictionary<string, object>();

                    var eventResponse = new RealtimeResponseEvent<Dictionary<string, object>>
                    {
                        Events = events,
                        Channels = channels,
                        Timestamp = timestamp,
                        Payload = payload
                    };

                    // Create a copy of subscriptions to avoid collection modification issues
                    var subscriptionsCopy = _subscriptions.Values.ToArray();
                    foreach (var subscription in subscriptionsCopy)
                    {
                        foreach (var channel in channels)
                        {
                            if (subscription.Channels.Contains(channel))
                            {
                                subscription.OnMessage?.Invoke(eventResponse);
                                break;
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                OnError?.Invoke(ex);
            }
        }

        private void OnWebSocketError(string error)
        {
            Debug.LogError($"[Realtime] WebSocket error: {error}");
            OnError?.Invoke(new {{ spec.title | caseUcfirst }}Exception($"WebSocket error: {error}"));
            Retry();
        }

        private void OnWebSocketClose(WebSocketCloseCode closeCode)
        {
            Debug.Log($"[Realtime] WebSocket closed with code: {closeCode}");
            StopHeartbeat();
            OnDisconnected?.Invoke();
            if (_reconnect && closeCode != WebSocketCloseCode.PolicyViolation)
            {
                Retry();
            }
        }

        private void StartHeartbeat()
        {
            StopHeartbeat();
            _heartbeatTokenSource = new CancellationTokenSource();
            
            UniTask.Create(async () =>
            {
                try
                {
                    while (!_heartbeatTokenSource.Token.IsCancellationRequested && _webSocket?.State == WebSocketState.Open)
                    {
                        await UniTask.Delay(TimeSpan.FromSeconds(20), cancellationToken: _heartbeatTokenSource.Token);
                        
                        if (_webSocket?.State == WebSocketState.Open && !_heartbeatTokenSource.Token.IsCancellationRequested)
                        {
                            var pingMessage = new { type = "ping" };
                            var json = JsonSerializer.Serialize(pingMessage, Client.SerializerOptions);
                            _webSocket.SendText(json);
                        }
                    }
                }
                catch (OperationCanceledException)
                {
                    // Expected when cancellation is requested
                }
                catch (Exception ex)
                {
                    OnError?.Invoke(ex);
                }
            });
        }

        private void StopHeartbeat()
        {
            _heartbeatTokenSource?.Cancel();
            _heartbeatTokenSource?.Dispose();
            _heartbeatTokenSource = null;
        }

        private void Retry()
        {
            if (!_reconnect) return;
            
            _reconnectAttempts++;
            var timeout = GetTimeout();
            
            Debug.Log($"Reconnecting in {timeout} seconds.");
            
            UniTask.Create(async () =>
            {
                await UniTask.Delay(TimeSpan.FromSeconds(timeout));
                await CreateSocket();
            });
        }

        private int GetTimeout()
        {
            return _reconnectAttempts < 5 ? 1 :
                   _reconnectAttempts < 15 ? 5 :
                   _reconnectAttempts < 100 ? 10 : 60;
        }

        private string PrepareUri()
        {
            var realtimeEndpoint = _client.Config.TryGetValue("endpointRealtime", out var endpoint) ? endpoint : null;
            if (string.IsNullOrEmpty(realtimeEndpoint))
            {
                throw new {{ spec.title | caseUcfirst }}Exception("Please set endPointRealtime to connect to realtime server");
            }

            var project = _client.Config.TryGetValue("project", out var proj) ? proj : "";
            
            // Format channels as separate query parameters like Flutter does
            var channelParams = string.Join("&", _channels.Select(c => $"channels[]={Uri.EscapeDataString(c)}"));
            
            var uri = new Uri(realtimeEndpoint);
            var realtimePath = uri.AbsolutePath.TrimEnd('/') + "/realtime";
            
            // Don't manually add port - let Uri handle it like Flutter does
            var baseUrl = $"{uri.Scheme}://{uri.Host}";
            if ((uri.Scheme == "wss" && uri.Port != 443) || (uri.Scheme == "ws" && uri.Port != 80))
            {
                baseUrl += $":{uri.Port}";
            }
            
            return $"{baseUrl}{realtimePath}?project={Uri.EscapeDataString(project)}&{channelParams}";
        }

        private async UniTask CloseConnection()
        {
            _reconnect = false;
            StopHeartbeat();
            _cancellationTokenSource?.Cancel();
            
            if (_webSocket != null)
            {
                await _webSocket.Close();
            }
            
            _lastUrl = null;
            _reconnectAttempts = 0;
        }

        /// <summary>
        /// Disconnect from realtime
        /// </summary>
        public async UniTask Disconnect()
        {
            await CloseConnection();
        }
        
        /// <summary>
        /// Dispose method for proper cleanup
        /// </summary>
        public void Dispose()
        {
            UniTask.Create(async () => await Disconnect()).Forget();
        }
    }
}
