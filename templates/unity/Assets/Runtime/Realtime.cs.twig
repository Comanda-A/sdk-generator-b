#if UNI_TASK
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using Cysharp.Threading.Tasks;
using UnityEngine;
using NativeWebSocket;

namespace {{ spec.title | caseUcfirst }}
{
    #region Realtime Data Models
    // Base classes for WebSocket messages
    internal class RealtimeMessageBase
    {
        [JsonPropertyName("type")]
        public string Type { get; set; }
    }

    internal class RealtimeMessage<T> : RealtimeMessageBase
    {
        [JsonPropertyName("data")]
        public T Data { get; set; }
    }

    // Models for incoming event data
    public class RealtimeResponseEvent<T>
    {
        [JsonPropertyName("events")]
        public string[] Events { get; set; }
        [JsonPropertyName("channels")]
        public string[] Channels { get; set; }
        [JsonPropertyName("timestamp")]
        public long Timestamp { get; set; }
        [JsonPropertyName("payload")]
        public T Payload { get; set; }
    }
    
    // Models for outgoing messages
    internal class RealtimeSubscriptionData
    {
        [JsonPropertyName("channels")]
        public string[] Channels { get; set; }
    }
    #endregion

    /// <summary>
    /// Realtime subscription for Unity
    /// </summary>
    public class RealtimeSubscription
    {
        public string[] Channels { get; internal set; }
        public Action<RealtimeResponseEvent<Dictionary<string, object>>> OnMessage { get; internal set; }
        internal Action OnClose { get; set; }

        /// <summary>
        /// Close this subscription
        /// </summary>
        public void Close()
        {
            OnClose?.Invoke();
        }
    }

    /// <summary>
    /// Realtime connection interface for Unity WebSocket communication
    /// </summary>
    public class Realtime : MonoBehaviour
    {
        private Client _client;
        private WebSocket _webSocket;
        private readonly Dictionary<int, RealtimeSubscription> _subscriptions = new();
        private int _subscriptionCounter;
        private bool _isManualDisconnect;
        private int _reconnectAttempts;
        private CancellationTokenSource _cancellationTokenSource;
        private readonly SemaphoreSlim _socketLock = new(1, 1);

        public bool IsConnected => _webSocket?.State == WebSocketState.Open;
        public event Action OnConnected;
        public event Action OnDisconnected;
        public event Action<Exception> OnError;

        public void Initialize(Client client)
        {
            _client = client;
            _cancellationTokenSource = new CancellationTokenSource();
        }

        void Update()
        {
            #if !UNITY_WEBGL || UNITY_EDITOR
            _webSocket?.DispatchMessageQueue();
            #endif
        }

        public RealtimeSubscription Subscribe(string[] channels, Action<RealtimeResponseEvent<Dictionary<string, object>>> callback)
        {
            var subscriptionId = ++_subscriptionCounter;
            var subscription = new RealtimeSubscription
            {
                Channels = channels,
                OnMessage = callback,
                OnClose = () => CloseSubscription(subscriptionId, channels)
            };

            _subscriptions[subscriptionId] = subscription;
            
            UniTask.Create(async () =>
            {
                await EnsureSocketConnected();
                await SendSubscriptionMessage("subscribe", channels);
            });

            return subscription;
        }

        private void CloseSubscription(int subscriptionId, string[] channels)
        {
            if (!_subscriptions.Remove(subscriptionId)) return;

            UniTask.Create(async () =>
            {
                if (IsConnected)
                {
                    await SendSubscriptionMessage("unsubscribe", channels);
                }

                if (_subscriptions.Count == 0)
                {
                    await Disconnect();
                }
            });
        }

        private async UniTask EnsureSocketConnected()
        {
            if (IsConnected) return;

            await _socketLock.WaitAsync(_cancellationTokenSource.Token);
            try
            {
                // Double-check after acquiring the lock
                if (IsConnected) return;

                var uri = PrepareUri();
                _webSocket = new WebSocket(uri);
                SetupWebSocketEvents();
                
                _isManualDisconnect = false;
                await _webSocket.Connect();
            }
            catch (Exception ex)
            {
                OnError?.Invoke(ex);
                Debug.LogError($"[Realtime] Connection failed: {ex.Message}");
                await HandleReconnect();
            }
            finally
            {
                _socketLock.Release();
            }
        }

        private void SetupWebSocketEvents()
        {
            _webSocket.OnOpen += OnWebSocketOpen;
            _webSocket.OnMessage += OnWebSocketMessage;
            _webSocket.OnError += OnWebSocketError;
            _webSocket.OnClose += OnWebSocketClose;
        }

        private void OnWebSocketOpen()
        {
            _reconnectAttempts = 0;
            OnConnected?.Invoke();
            Debug.Log("[Realtime] WebSocket opened successfully.");
        }

        private void OnWebSocketMessage(byte[] data)
        {
            try
            {
                var message = Encoding.UTF8.GetString(data);
                var baseMessage = JsonSerializer.Deserialize<RealtimeMessageBase>(message, Client.DeserializerOptions);

                switch (baseMessage.Type)
                {
                    case "event":
                        var eventMsg = JsonSerializer.Deserialize<RealtimeMessage<RealtimeResponseEvent<Dictionary<string, object>>>>(message, Client.DeserializerOptions);
                        HandleRealtimeEvent(eventMsg.Data);
                        break;
                    case "error":
                        var errorMsg = JsonSerializer.Deserialize<RealtimeMessage<Dictionary<string, object>>>(message, Client.DeserializerOptions);
                        HandleErrorMessage(errorMsg.Data);
                        break;
                    // Other message types like 'connected', 'pong' can be handled here if needed.
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[Realtime] Message processing failed: {ex.Message}");
                OnError?.Invoke(ex);
            }
        }

        private void HandleRealtimeEvent(RealtimeResponseEvent<Dictionary<string, object>> eventData)
        {
            var subscriptionsCopy = _subscriptions.Values.ToArray();
            foreach (var subscription in subscriptionsCopy)
            {
                if (subscription.Channels.Any(subChannel => eventData.Channels.Contains(subChannel)))
                {
                    subscription.OnMessage?.Invoke(eventData);
                }
            }
        }

        private void HandleErrorMessage(Dictionary<string, object> errorData)
        {
            var message = errorData.TryGetValue("message", out var msgObj) ? msgObj.ToString() : "Unknown realtime error";
            var code = errorData.TryGetValue("code", out var codeObj) ? Convert.ToInt32(codeObj.ToString()) : 0;
            OnError?.Invoke(new {{ spec.title | caseUcfirst }}Exception(message, code));
        }

        private void OnWebSocketError(string error)
        {
            OnError?.Invoke(new {{ spec.title | caseUcfirst }}Exception($"WebSocket error: {error}"));
        }

        private void OnWebSocketClose(WebSocketCloseCode closeCode)
        {
            OnDisconnected?.Invoke();
            if (!_isManualDisconnect)
            {
                HandleReconnect().Forget();
            }
        }

        private async UniTask HandleReconnect()
        {
            if (_isManualDisconnect) return;
            
            _reconnectAttempts++;
            var timeout = GetTimeout();
            Debug.Log($"[Realtime] Reconnecting in {timeout} seconds.");
            
            await UniTask.Delay(TimeSpan.FromSeconds(timeout), cancellationToken: _cancellationTokenSource.Token);
            await EnsureSocketConnected();
        }

        private int GetTimeout() => _reconnectAttempts switch
        {
            < 5 => 1,
            < 15 => 5,
            < 100 => 10,
            _ => 60
        };

        private string PrepareUri()
        {
            var realtimeEndpoint = _client.Config.GetValueOrDefault("endpointRealtime");
            if (string.IsNullOrEmpty(realtimeEndpoint))
                throw new {{ spec.title | caseUcfirst }}Exception("Please set endPointRealtime to connect to realtime server");

            var project = _client.Config.GetValueOrDefault("project", "");
            return $"{realtimeEndpoint}?project={Uri.EscapeDataString(project)}&channels[]=files"; // Initial channel required
        }

        private async UniTask SendSubscriptionMessage(string type, string[] channels)
        {
            if (!IsConnected) return;
            
            var message = new RealtimeMessage<RealtimeSubscriptionData>
            {
                Type = type,
                Data = new RealtimeSubscriptionData { Channels = channels }
            };
            var json = JsonSerializer.Serialize(message, Client.SerializerOptions);
            await _webSocket.SendText(json);
        }

        public async UniTask Disconnect()
        {
            _isManualDisconnect = true;
            if (_webSocket != null)
            {
                await _webSocket.Close();
            }
        }

        private async void OnDestroy()
        {
            _cancellationTokenSource?.Cancel();
            _cancellationTokenSource?.Dispose();
            await Disconnect();
        }
    }
}
#endif
